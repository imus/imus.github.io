---
title: http 缓存
tags:
---

####  http缓存（web缓存）

[	http缓存MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ#Freshness)

[	web缓存 维基百科](https://zh.wikipedia.org/wiki/Web%E7%BC%93%E5%AD%98)

- 概述

  **Web缓存**（或**HTTP缓存**）是用于临时存储Web文档，以减少服务器延迟的一种信息技术。Web缓存系统会保存下通过这套系统的文档的副本；如果满足某些条件，则可以由缓存满足后续请求。 Web缓存系统既可以指设备，也可以指计算机程序。

  **当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）**

   

- 缓存类型

  **(私有)浏览器缓存，前向位置系统（接受者或客户端）**

  为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。

  **(共享)代理缓存，反向位置系统（内容提供者或Web服务器端）**

  可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。

- 缓存控制

  常见的 HTTP 缓存只能存储 [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET) 响应，对于其他类型的响应则无能为力。

  HTTP定义了三种控制缓存的基本机制：新鲜度，验证和失效。

  HTTP/1.1定义的 [`Cache-Control`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control) 头用来区分对缓存机制的**支持**情况， **请求头和响应头**都支持这个属性。

  Cache-Control: 

  ​	no-store, // 禁止进行缓存,每次由客户端发起的请求都会下载完整的响应内容。

  ​	no-cache, // 强制确认缓存,每次有请求发出时，缓存会将此请求发到服务器（译者注：该请求应						该会带有与本地缓存相关的验证字段），服务器端会验证请求中所描述的缓存是否过						期，若未过期（注：实际就是返回304），则缓存才使用本地缓存副本。

  ​	public, //表示该响应可以被任何中间人（译者注：比如中间代理、CDN等）缓存。若指定				了"public"，则一些通常不被中间人缓存的页面（译者注：因为默认是private）（比如 带				有HTTP验证信息（帐号密码）的页面 或 某些特定状态码的页面），将会被其缓存。

  ​	private,//表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器				私有缓存中。

  ​	max-age=31536000，//资源能够被缓存（保持新鲜）的最大时间

  ​	must-revalidate, //意味着缓存在考虑使用一个陈旧的资源时，必须先验证它的状态，已过期的缓								存将不被使用。

  ​	[`Pragma`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Pragma) 是HTTP/1.0标准中定义的一个header属性，请求中包含Pragma的效果跟在头信息中定义Cache-Control: no-cache相同，但是HTTP的响应头没有明确定义这个属性，所以它不能拿来完全替代HTTP/1.1中定义的Cache-control头。通常定义Pragma以向后兼容基于HTTP/1.0的客户端

  新鲜度 
  允许在不在源服务器上重新检查的情况下使用一个响应，并且可以由服务器和客户端来控制。例如，Expires响应头给出文档过期的日期，而Cache-Control: max-age指示告诉缓存该响应在多少秒内保持新鲜。

  验证 
  可用于检查缓存的响应是否过时之后仍然有效。例如，若响应有一个Last-Modified头，缓存可以使用If-Modified-Since头来发出一个条件请求，来查看它是否已经改变。ETag（实体标签）机制还允许强弱验证。

  失效 
  通常是另一个请求通过缓存的一个结果。例如，如果与缓存的响应关联的URL随后获得POST、PUT或DELETE请求，则缓存的响应将失效。
  许多CDN和网络设备制造商已经用动态缓存取代了这个标准的HTTP缓存控制。